var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [HeterogeneousComputing]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#HeterogeneousComputing.HeterogeneousComputing","page":"API","title":"HeterogeneousComputing.HeterogeneousComputing","text":"HeterogeneousComputing\n\nTools for heterogeneous computing in Julia.\n\n\n\n\n\n","category":"module"},{"location":"api/#HeterogeneousComputing.AbstractComputeAccelerator","page":"API","title":"HeterogeneousComputing.AbstractComputeAccelerator","text":"abstract type AbstractComputeAccelerator <: AbstractComputeUnit\n\nSupertype for GPU compute units.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.AbstractComputeUnit","page":"API","title":"HeterogeneousComputing.AbstractComputeUnit","text":"abstract type AbstractComputeUnit\n\nSupertype for arbitrary compute units (CPU, GPU, etc.).\n\nadapt(cunit::AbstractComputeUnit, x) adapts x for cunit.\n\nget_total_memory(cunit) and get_free_memory(cunit) return the total resp. the free memory on the compute unit.\n\nallocate_array(cunit, dims) can be used to allocate new arrays on cunit.\n\nKernelAbstractions.Backend(cunit) will return default KernelAbstractions backend for the type of the compute unit.\n\nSee also GenContext.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.AbstractGPUnit","page":"API","title":"HeterogeneousComputing.AbstractGPUnit","text":"abstract type AbstractGPUnit <: AbstractComputeAccelerator\n\nSupertype for GPU comute units.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.CPUnit","page":"API","title":"HeterogeneousComputing.CPUnit","text":"struct CPUnit <: AbstractComputeUnit\n\nCPUnit() is the default central processing unit (CPU).\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.ComputeUnitIndependent","page":"API","title":"HeterogeneousComputing.ComputeUnitIndependent","text":"struct ComputeUnitIndependent\n\nget_compute_unit(x) === ComputeUnitIndependent() indicates that x is not tied to a specific compute unit. This typically means that x is a statically allocated object.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.GenContext","page":"API","title":"HeterogeneousComputing.GenContext","text":"GenContext{T=AbstractFloat}(\n    rng::AbstractRNG = Random.default_rng(),\n    cunit::AbstractComputeUnit = CPUnit()\n)\n\nContext for generative computations.\n\nBase.eltype(ctx::GenContext)will returnT`.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.MixedComputeSystem","page":"API","title":"HeterogeneousComputing.MixedComputeSystem","text":"struct MixedComputeSystem <: AbstractComputeUnit\n\nA (possibly heterogenous) system of multiple compute units.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.NoGenContext","page":"API","title":"HeterogeneousComputing.NoGenContext","text":"struct HeterogeneousComputing.NoGenContext{T}\n\nIndicates that no generative context could be derived from an object of type T.\n\nSee get_gencontext for details.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.NoPrecision","page":"API","title":"HeterogeneousComputing.NoPrecision","text":"struct HeterogeneousComputing.NoPrecision{T}\n\nIndicates that no specific numerical precision associated with an object of type T could be determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.NoRNG","page":"API","title":"HeterogeneousComputing.NoRNG","text":"struct HeterogeneousComputing.NoRNG{T}\n\nIndicates that no specific random number generator associated with an object of type T could be determined.\n\nSee get_rng for details.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.UnknownComputeUnitOf","page":"API","title":"HeterogeneousComputing.UnknownComputeUnitOf","text":"UnknownComputeUnitOf(x)\n\nget_compute_unit(x) === ComputeUnitIndependent() indicates that the compute unit for x cannot be determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.allocate_array","page":"API","title":"HeterogeneousComputing.allocate_array","text":"allocate_array(cpunit::AbstractComputeUnit, ::Type{T}, dims::Dims)\nallocate_array(cpunit::AbstractComputeUnit, ::Type{T}, dims::Integer...)\n\nAllocate a new array with element type T and size dims on compute unit cunit.\n\nThe content of the newly allocated array is undefined.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.allocate_array-Union{Tuple{T}, Tuple{GenContext{T}, Tuple{Vararg{Int64, N}} where N}} where T","page":"API","title":"HeterogeneousComputing.allocate_array","text":"allocate_array(ctx::GenContext, dims::Dims)\nallocate_array(ctx::GenContext, dims::Integer...)\nallocate_array(ctx::GenContext, ::Type{T}, dims::Dims)\nallocate_array(ctx::GenContext, ::Type{T}, dims::Integer...)\n\nAllocate a new array on the compute unit and with the numerical element type specified by ctx.\n\nThe default element type can be overriden by specifying T.\n\n\n\n\n\n","category":"method"},{"location":"api/#HeterogeneousComputing.get_compute_unit","page":"API","title":"HeterogeneousComputing.get_compute_unit","text":"get_compute_unit(x)::Union{\n    AbstractComputeUnit,\n    ComputeUnitIndependent,\n    UnknownComputeUnitOf\n}\n\nGet the compute unit backing object x.\n\nDon't specialize get_compute_unit, specialize HeterogeneousComputing.get_compute_unit_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.get_compute_unit_impl","page":"API","title":"HeterogeneousComputing.get_compute_unit_impl","text":"HeterogeneousComputing.get_compute_unit_impl(::Type{TypeHistory}, x)::AbstractComputeUnit\n\nSee get_compute_unit_impl.\n\nSpecializations that directly resolve the compute unit based on x can ignore TypeHistory:\n\nHeterogeneousComputing.get_compute_unit_impl(@nospecialize(TypeHistory::Type), x::SomeType) = ...\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.get_free_memory","page":"API","title":"HeterogeneousComputing.get_free_memory","text":"getfreememory(cunit::AbstractComputeUnit)\n\nGet the amount of free memory available on cunit.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.get_gencontext","page":"API","title":"HeterogeneousComputing.get_gencontext","text":"get_gencontext(x::T)\n\nGet the generative context associated with x or NoGenContext{T} if no context can be determined for x.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.get_precision","page":"API","title":"HeterogeneousComputing.get_precision","text":"get_precision(x::T)::Union{\n    Type{<:AbstractFloat},\n    Type{<:HeterogeneousComputing.NoPrecision}\n}\n\nReturns the numerical precision of used by x or NoPrecision{T} if no numerical precision can be determined for x.\n\nIn general, do not specialize get_precision, specialize get_precision_fromtype  instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.get_precision_fromtype","page":"API","title":"HeterogeneousComputing.get_precision_fromtype","text":"get_precision_fromtype(::Type{T})\n\nReturns the numberical precision accociate with type T or NoPrecision{T} if no numerical precision can be determined for type T.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.get_rng","page":"API","title":"HeterogeneousComputing.get_rng","text":"get_rng(x::T)\n\nTries to determine the random number generator used by x.\n\nReturns NoRNG{T}() if x doesn't seem to be associated with a specific random number generator.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.get_total_memory","page":"API","title":"HeterogeneousComputing.get_total_memory","text":"get_total_memory(cunit::AbstractComputeUnit)\n\nGet the total amount of memory available on cunit.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.ka_backend","page":"API","title":"HeterogeneousComputing.ka_backend","text":"HeterogeneousComputing.ka_backend(cunit::AbstractComputeUnit)\n\nReturns the KernelAbstractions backend for cunit.\n\nRequires KernelAbstractions.jl to be loaded, otherwise ka_backend will have no methods.\n\nDo not call directly, use for specialization only.\n\nUser code should call KernelAbstractions.Backend(cunit) or convert(KernelAbstractions.Backend, cunit) instead, both of which will use ka_backend internally.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.merge_compute_units","page":"API","title":"HeterogeneousComputing.merge_compute_units","text":"merge_compute_units(compute_units...)\n\nMerge compute_units unto a common/combined compute unit.\n\nDo not specialize merge_compute_units directly, specialize compute_unit_mergerule(a, b) instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.real_numtype","page":"API","title":"HeterogeneousComputing.real_numtype","text":"real_numtype(T::Type)\n\nReturn the underlying numerical type of T that's a subtype of Real.\n\nUses type promotion among underlying Real type in T.\n\nNon numerical types that are commonly used to express default and missing values or named choices/options are treated as Bool.\n\nIn contract to get_precision_fromtype, the function real_numtype may also return subtypes of Integer and will preserve types like ForwardDiff.Dual.\n\nExample:\n\n\nA = fill(fill(rand(Float32, 5), 10), 5)\nreal_numtype(typeof(A)) == Float32\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#HeterogeneousComputing.jl","page":"Home","title":"HeterogeneousComputing.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HeterogeneousComputing.jl provides tools to ease heterogeneous computing in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently only CPU and CUDA units are supports, support for AMDGPU, oneAPI and Metal will be added as well.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package provides AbstractComputeUnit and GenContext which allow for determining which compute unit given content is currently located on, moving it to other compute units, and generating new data on specific compute units.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The idea is that a AbstractComputeUnit or an AbstractComputeUnit (which compines a compute unit with a random number generator and a desired numerical precision) can be passed around and propagate through an application, so that the computational context is always available.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using HeterogeneousComputing\nusing Random, Adapt, CUDA, StructArrays, Tables\n\n# Generate some data on a GPU:\ncpu_data = StructArray((\n    a = rand(Float32, 1000),\n    b = rand(Float32, 1000),\n))\n\n# Verify data is on GPU:\ncpu_unit = CPUnit()\nget_compute_unit(cpu_data) == cpu_unit\n\n# Get compute unit for the current CUDA device:\ngpu_unit = AbstractComputeUnit(CUDA.device())\n\n# Move the data to the GPU:\n\ngpu_data = adapt(gpu_unit, cpu_data)\n\n# Specify a context for content generation.\n\ngpu_ctx = GenContext{Float32}(gpu_unit)\n\n# Generate a new data column on the GPU and add it to the data. A context\n# can also be used directly for random number generation, so we can\n# generate random data of the desired numerical precision on the desired\n# compute unit very conventiently:\n\nc = rand!(allocate_array(gpu_ctx, 1000))\nd = rand(gpu_ctx, 1000)\n\nnew_gpu_data = new_gpu_data = StructArray(\n    merge(Tables.columns(gpu_data), (c = c, d = c))\n)\n\n# Move the data back to the CPU:\n\nnew_cpu_data = adapt(cpu_unit, new_gpu_data)","category":"page"},{"location":"#Support-for-KernelAbstractions","page":"Home","title":"Support for KernelAbstractions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HeterogeneousComputing also has support for KernelAbstractions, a KernelAbstractions.Backend can be derived from an AbstractComputeUnit:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using KernelAbstractions\nka_backend = KernelAbstractions.Backend(gpu_unit)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This way, KernelAbstractions backends don't need to be tracked independently through a an application.","category":"page"}]
}
