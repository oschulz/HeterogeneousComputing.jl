var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [HeterogeneousComputing]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#HeterogeneousComputing.HeterogeneousComputing","page":"API","title":"HeterogeneousComputing.HeterogeneousComputing","text":"HeterogeneousComputing\n\nTools for heterogeneous computing in Julia.\n\n\n\n\n\n","category":"module"},{"location":"api/#HeterogeneousComputing.AbstractComputeAccelerator","page":"API","title":"HeterogeneousComputing.AbstractComputeAccelerator","text":"abstract type AbstractComputeAccelerator <: AbstractComputeUnit\n\nSupertype for GPU compute units.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.AbstractComputeUnit","page":"API","title":"HeterogeneousComputing.AbstractComputeUnit","text":"abstract type AbstractComputeUnit\n\nSupertype for arbitrary compute units (CPU, GPU, etc.).\n\nadapt(dev::AbstractComputeUnit, x) adapts x for dev.\n\nSys.total_memory(dev) and Sys.free_memory(dev) return the total and free memory on the unit.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.AbstractGPUnit","page":"API","title":"HeterogeneousComputing.AbstractGPUnit","text":"abstract type AbstractGPUnit <: AbstractComputeAccelerator\n\nSupertype for GPU comute units.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.CPUnit","page":"API","title":"HeterogeneousComputing.CPUnit","text":"struct CPUnit <: AbstractComputeUnit\n\nCPUnit() is the default central processing unit (CPU).\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.ComputeUnitIndependent","page":"API","title":"HeterogeneousComputing.ComputeUnitIndependent","text":"struct ComputeUnitIndependent\n\nget_compute_unit(x) === ComputeUnitIndependent() indicates that x is not tied to a specific compute unit. This typically means that x is a statically allocated object.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.MixedComputeSystem","page":"API","title":"HeterogeneousComputing.MixedComputeSystem","text":"struct MixedComputeSystem <: AbstractComputeUnit\n\nA (possibly heterogenous) system of multiple compute units.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.UnknownComputeUnitOf","page":"API","title":"HeterogeneousComputing.UnknownComputeUnitOf","text":"UnknownComputeUnitOf(x)\n\nget_compute_unit(x) === ComputeUnitIndependent() indicates that the compute unit for x cannot be determined.\n\n\n\n\n\n","category":"type"},{"location":"api/#HeterogeneousComputing.get_compute_unit","page":"API","title":"HeterogeneousComputing.get_compute_unit","text":"get_compute_unit(x)::Union{\n    AbstractComputeUnit,\n    ComputeUnitIndependent,\n    UnknownComputeUnitOf\n}\n\nGet the compute unit backing object x.\n\nDon't specialize get_compute_unit, specialize HeterogeneousComputing.get_compute_unit_impl instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.get_compute_unit_impl","page":"API","title":"HeterogeneousComputing.get_compute_unit_impl","text":"HeterogeneousComputing.get_compute_unit_impl(::Type{TypeHistory}, x)::AbstractComputeUnit\n\nSee get_compute_unit_impl.\n\nSpecializations that directly resolve the compute unit based on x can ignore TypeHistory:\n\nHeterogeneousComputing.get_compute_unit_impl(@nospecialize(TypeHistory::Type), x::SomeType) = ...\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.get_free_memory","page":"API","title":"HeterogeneousComputing.get_free_memory","text":"getfreememory(cunit::AbstractComputeUnit)\n\nGet the amount of free memory available on cunit.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.get_total_memory","page":"API","title":"HeterogeneousComputing.get_total_memory","text":"get_total_memory(cunit::AbstractComputeUnit)\n\nGet the total amount of memory available on cunit.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.ka_backend","page":"API","title":"HeterogeneousComputing.ka_backend","text":"HeterogeneousComputing.ka_backend(cunit::AbstractComputeUnit)\n\nReturns the KernelAbstractions backend for cunit.\n\nRequires KernelAbstractions.jl to be loaded, otherwise ka_backend will have no method.\n\nDo not call directly, use for specialization only.\n\nUser code should call KernelAbstractions.Backend(cunit)) or convert(KernelAbstractions.Backend, cunit) instead, both of which will use ka_backend internally.\n\n\n\n\n\n","category":"function"},{"location":"api/#HeterogeneousComputing.merge_compute_units","page":"API","title":"HeterogeneousComputing.merge_compute_units","text":"merge_compute_units(compute_units...)\n\nMerge compute_units unto a common/combined compute unit.\n\nDo not specialize merge_compute_units directly, specialize compute_unit_mergerule(a, b) instead.\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#HeterogeneousComputing.jl","page":"Home","title":"HeterogeneousComputing.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HeterogeneousComputing.jl provides tools to ease heterogeneous computing in Julia.","category":"page"}]
}
